<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <link rel="icon" href="img/eslogo196.png">
   <link rel="stylesheet" type="text/css" href="style.css">
   <link rel="stylesheet" href="highlight/matlab.css">
   <script src="highlight/highlight.pack.js"></script>
   <script>hljs.initHighlightingOnLoad();</script>
   <title>User guide: pulse EPR</title>
</head>

<body>

<header>
<ul>
<li><img src="img/eslogo42.png">
<li class="header-title">EasySpin
<li><a href="index.html">Documentation</a>
<li><a href="references.html">Publications</a>
<li><a href="http://easyspin.org" target="_blank">Website</a>
<li><a href="http://easyspin.org/forum" target="_blank">Forum</a>
</ul>
</header>

<section>

<div class="functitle">Advances pulse EPR simulations and spin dynamics</div>

<p>
This user guide explains how to simulate a variety of pulse EPR spectra, using EasySpin's function <a class="esf" href="saffron.html">saffron</a>.
</p>

<a name="relaxation_times">
<div class="subtitle">Relaxation Times</div>
<p>
The simplest way to use relaxation is to apply the same longitudinal and transverse relaxation times (in microseconds) to all transitions of the spin system.
A 1.5 microseconds longitudinal relaxation time and a 0.5 microseconds transverse relaxation time can be assigned to all transitions in the system with
</p>

<pre class="matlab">
Sys.T1 = 1.5;  % longitudinal relaxation time in microseconds
Sys.T2 = 0.5;  % transverse relaxation time in microseconds
</pre>

<p>
In some cases, it might be of interest to investigate the effect of only one type of relaxation: If only <code>T1</code> or <code>T2</code> are defined, the missing relaxation time is by default set to 10<sup>10</sup> microseconds.
</p>

<p>
In systems with larger spin quantum numbers or several spins, relaxation times can differ for different types of transitions.
If you do not want to use the same relaxation time for each transition, relaxation times can also be provided in matrices. 
To set up the input correctly, some knowledge of the spin system and the resulting density matrices is required:
For a single-spin system the basis functions of the operators in the Zeeman basis state are in descending order, left to right (more at <a href="sop.html">sop</a>).
E.g., an <i>S</i> = 1 system has three states and the three pathways connecting them can be described by a 3 &times; 3 (density like) matrix:
</p>

<img src="img/spidyan_relaxation1.png" width="250">

<p>
With this we can now design matrix input for <code>T1</code> and <code>T2</code>, that can be translated into a relaxation superoperator:
</p>

<pre class="matlab">
Sys.T1(1,2) = 1.5;  % transition 1 (blue)
Sys.T1(1,3) = 0.5;  % transition 2 (green)
Sys.T1(2,3) = 1.4;  % transition 3 (red)

Sys.T2(1,2) = 0.3;  % transition 1 (blue)
Sys.T2(1,3) = 0.1;  % transition 2 (green)
Sys.T2(2,3) = 0.3;  % transition 3 (red)
</pre>

<pre class="mloutput">
Sys.T1 =
		0		1.5		0.5
		0		  0		1.4
		0		  0		  0
		
Sys.T2 =
		0		0.3		0.1
		0		  0		0.3
		0		  0		  0
</pre>

<p>
It suffices to define the upper triangle only (as done above). 
But for longitudinal (not so for transverse) relaxation there can be a difference between "up" (|+1>&#8594;|0>) and "down" (|0>&#8594;|+1>) pathways. 
If you are interested in assigning different relaxation times for opposing directions, you can do this by using the lower triangle:
</p>

<pre class="matlab">
Sys.T1(2,1) = 1.3;  % transition 1 (grey)
Sys.T1(3,1) = 0.7;  % transition 2 (grey)
Sys.T1(3,2) = 1.1;  % transition 3 (grey)
</pre>

<pre class="mloutput">
Sys.T1 =
		  0		1.5		0.5
		1.3		  0		1.4
		0.7		1.1		  0
</pre>

<p>
In case the lower triangle is not defined for <code>T1</code>, the upper triangle is used for up and down directions.
Any transitions that are not assigned a relaxation time (matrix element 0 in the upper triangle), are automatically set to 10<sup>10</sup> microseconds, which effectively switches relaxation off on that pathway. 
Relaxation times  in the lower triangle of <code>T2</code> are ignored.
</p>

<p>
Spin systems that contain several spins are assigned relaxation times analogously, but require a slightly deeper insight into ordering of the states:
The representation of the operators is in terms of product Zeeman basis states |m<sub>1</sub>,m<sub>2</sub>,m<sub>3</sub>,..>, where m<sub>1</sub> is for the first spin, m<sub>2</sub> is for the second spin, etc.
The basis functions are again in descending order m<sub>i</sub>, left to the right.
E.g. for two coupled (electron) spins with <i>S,</i> = 1/2, you get the following energy level scheme:
</p>

<img src="img/spidyan_relaxation2.png" width="450">

<div class="subtitle">Tips and Tricks</div>
<ul>
<li> 
If you are interested in the expectation values of <i>&Scirc;<sub>x</sub></i>, it is usually beneficial to use <i>&Scirc;</i><sub>+</sub> as the actual detection operator and then take the real part of the obtained signal.
This removes artifacts at the beginning and end of the time traces that are introduced when translating a purely real signal during the signal processing.
<li> 
In some simulations you may observe echoes in your timetrace that should not be there.
Besides physical reasons (incomplete phase cycling, different refocusing conditions,...), such artifact echoes can arise from an aliasing effect if the spectrum (e.g. the nitroxide spectrum in the example above) is insufficiently sampled.
This can easily be checked: By increasing the number of samples from your distribution the artifact echoes should move, spread further apart or vanish, while physical echos stay in place. You can also compute the required increment for the spin packet distribution in frequency domain by an inverse Nyquist criterion. 
If you want to observe up to a time <i>t</i><sub>max</sub> after the first excitation event (first pulse), the frequency increment should not be larger than 1/(2 <i>t</i><sub>max</sub>). Otherwise use Monte Carlo sampling of spin packet frequencies, which will convert the artifacts to 'Monte Carlo noise' that averages with increasing number of trials.  
<li> 
If the signal processing fails, <code>spidyan</code> returns the signal in the simulation frame. 
This can happen if you try to translate <i>&Scirc;<sub>z</sub></i> or provide a wrong frequency. 
Instead of adapting down conversion and rerunning the entire simulation, you can call <code>signalprocessing</code> with the original signal and the correct down conversion frequencies.
More info on <a class="esf" href="signalprocessing.html">signalprocessing</a>.
</ul>
<hr>
</section>

<footer></footer>

</body>
</html>
