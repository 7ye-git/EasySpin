<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <link rel="icon" href="img/eslogo196.png">
   <link rel="stylesheet" type="text/css" href="style.css">
   <link rel="stylesheet" href="highlight/matlab.css">
   <script src="highlight/highlight.pack.js"></script>
   <script>hljs.initHighlightingOnLoad();</script>
   <title>spidyan</title>
</head>

<body>

<header>
<ul>
<li><img src="img/eslogo42.png">
<li class="header-title">EasySpin
<li><a href="index.html">Documentation</a>
<li><a href="references.html">Publications</a>
<li><a href="http://easyspin.org" target="_blank">Website</a>
<li><a href="http://easyspin.org/forum" target="_blank">Forum</a>
</ul>
</header>

<section>

<!-- ====================================================== -->
<div class="functitle">spidyan</div>

<p>
Simulation of spin dynamics with arbitrary wave forms.
</p>

<div class="subtitle">Syntax</div>

<pre class="matlab">
spidyan(Sys,Exp)
spidyan(Sys,Exp,Opt)
y = spidyan(...)
[x,y] = spidyan(...)
[x,y,s] = spidyan(...)
[x,y,s,t] = spidyan(...)
</pre>

<p>
See also the <a href="examplesmain.html">examples</a> on how to use <code>spidyan</code>.

<!-- ====================================================== -->
<div class="subtitle">Description</div>

<p>
This function simulates spin dynamics of pulse EPR experiments with arbitrary waveforms.


<div class="subtitle2">Outputs</div>

<p>
There are up to four possible output arguments.

<p>
<ul>
<li>
The output contains the abscissa data in <code>x</code> (time in microseconds) and the simulated data in <code>y</code> (time domain trace). 
If for a multidimensional experiment all time traces have the same length, <code>x</code> and <code>y</code> are numeric arrays. 
For multidimensional simulations where the length of the trace changes, <code>x</code> and <code>y</code> are cell arrays.
<li>
<code>s</code> is the final state (states for a multidimensional experiment) after propagation.
<li> The cell array <code>t</code> contains state trajectories (density matrices) at each point of detection and is available only if requested through <code>Opt.StateTrajectories</code>.
</ul>

<div class="subtitle2">Input: Spin system</div>

<p>
The three input arguments to the function are

<ul>
<li><code>Sys</code>: spin system (paramagnetic molecule)</li>
<li><code>Exp</code>: experimental parameters</li>
<li><code>Opt</code>: simulation options</li>
</ul>

<p>
<code>Sys</code> is a <a href="spinsystem.html">spin system structure</a>. 
Fields available in <code>Sys</code> include all needed for the construction of the spin Hamiltonian. 
Line broadening parameters used by other simulation functions (<code>lw</code>, <code>lwpp</code>, <code>gStrain</code>, etc.) are not recognized.
To facilitate spin dynamic simulations the field <code>ZeemanFreq</code> is available.
This is <code>spidyan</code>-specific and does not work with any other functions.
For simulations with relaxation at least <code>T1</code> or <code>T2</code> must be provided.
If either is not provided, it is set to a very large value (1e^10 microseconds), essentially switching that type of relaxation off.


<div class="optionfield"><code>ZeemanFreq</code></div>
<div class="optiondescr">
An array that contains Zeeman frequencies (in GHz) of electron spins defined in <code>S</code> of the spin system structure. 
It is to use  <code>ZeemanFreq</code> in combination with <code>g</code>. 
If a non-zero Zeeman frequency is found, any g-values given for that electron spins are ignored.
</div>

<div class="optionfield"><code>T1</code></div>
<div class="optiondescr">
Longitudinal relaxation time in microseconds. 
If it is a scalar, the relaxation time is applied to all transitions. 
Transition specific relaxation times can be provided in the form of a matrix.
See the example on how to setup the relaxation matrix for more details. 
Relaxation times for transitions that are not defined (0) are automatically assumed to be very large (1e^10 microseconds).
</div>

<div class="optionfield"><code>T2</code></div>
<div class="optiondescr">
Transverse relaxation time in microseconds. 
If it is a scalar, the relaxation time is applied to all transitions. 
Transition specific relaxation times can be provided in the form of a matrix.
See the example on how to setup the relaxation matrix for more details. 
Relaxation times for transitions that are not defined (0) are automatically assumed to be very large (1e^10).
</div>

<div class="optionfield"><code>initState</code></div>
<div class="optiondescr">
It is possible to run <code>spidyan</code> simulations with a custom initial state, which must be provided in matrix form.
By default, the initial state assumes polarization of all electron spins along the z axis of the magnetic field.
</div>

<div class="optionfield"><code>eqState</code></div>
<div class="optiondescr">
For simulations with relaxation it is possible to provide an eqState which the system relaxes to, which has to be in matrix form.
By default the equilibrium state is used as equilibrium state.
</div>



<div class="subtitle2">Input: Experimental parameters</div>
<p>
<code>Exp</code> contains the experimental parameters, most importantly the magnetic field and the pulse sequence.
</p>

<div class="optionfield"><code>Field</code></div>
<div class="optiondescr">
Magnetic field (in mT) at which the experiment is performed.
</div>

<div class="optionfield"><code>TimeStep</code></div>
<div class="optiondescr">
Time step in microseconds. If the Nyquist criteriums is not fulfilled an error is returned. 
The required <code>TimeStep</code> depends on the choice of simulation frame, and hence <code>Opt.FrameShift</code> (see there and in the examples).
</div>

<div class="optionfield"><code>t</code></div>
<div class="optiondescr">
Vector that contains the lengths of all the events (pulses and free evolutions) in microseconds.
</div>

<div class="optionfield"><code>Pulses</code></div>
<div class="optiondescr">
A cell array that contains the pulse parameters with the indexing corresponds to <code>t</code>.
Free evolution events are declared with 0. 
If the pulse definition contains a field <code>Qcrit</code> or <code>Amplitude</code> the value in <code>Exp.Flip</code> is ignored.
If both <code>Qcrit</code> and <code>Amplitude</code> are provided, <code>Qcrit</code> takes priority.
</div>

<div class="optionfield"><code>Flip</code></div>
<div class="optiondescr">
A vector with flipangles for the pulses in radian.
The indexing corresponds NOT to the indexing in <code>t</code>, but to the pulse indexing:
e. g. the second element in <code>Flip</code> is the flip angle of the second pulse.
The entry of <code>Flip</code> is ignored if <code>Qcrit</code> or <code>Amplitude</code> are given in the pulse definition.
</div>

<div class="optionfield"><code>Frequency</code></div>
<div class="optiondescr">
Defines the frequency in GHz of the pulses in relation to  <code>mwFreq</code> or in absolute frequency.
For a monochromatic it is sufficient to provide one value, for frequency swept pulses an initial and final frequency must be provided.
In simulations with pulses with different excitation windows, the rows in the numeric array correspond to the pulse index.
See the example files for more information on how to set up pulses with different excitation windows. 
</div>

<div class="optionfield"><code>mwFreq</code></div>
<div class="optiondescr">
EPR spectrometer frequency in GHz.
If given, all frequencies in <code>Frequencies</code> need to be defined relative to it. 
Required for simulations with resonator.
</div>

<div class="optionfield"><code>DetEvents</code></div>
<div class="optiondescr">
A vector that controls detection. 
Can be set for the entire simulation or for specific events:
<pre class="matlab">
Exp.DetEvents = true;   	% the entire sequence is detected
Exp.DetEvents = [0 0 1 1];	% expectation values are only returned the third and fourth event
Exp.DetEvents = [];			% no detection
</pre>
By default, detection is off. 
Detection operators can be defined in <code>Opt.DetOperator</code>.
</div>

<div class="optionfield"><code>Phase</code></div>
<div class="optiondescr">
An optional vector with the phases of the pulses in radian, with the indexing corresponding to the pulse index.
If a phase is provided in the pulse definition, the value in <code>Phase</code> is added.
</div>

<div class="optionfield"><code>PhaseCycle</code></div>
<div class="optiondescr">
Cell array that contains the individual phase cycles, with the indexing corresponding to the pulse indices.
The phase cycle itself needs to be given in array form, where rows correspond to the phase cycling steps. 
In each row the first element is the phase, and the second element the detection sign.
<pre class="matlab">
PC = [0, 1; pi, -1];   		% phase cycle
Exp.PhaseCycle = {[] PC};	% phase cycles the second pulse
</pre>
</div>

<p>
It is possible to run multidimensional simulations:
</p>

<div class="optionfield"><code>nPoints</code></div>
<div class="optiondescr">
A vector that contains the number of points in each dimension, e. g. [10 150] corresponds to 10 points in the first and 150 points in the second dimension. 
There is no limit on the number of dimensions.
</div>

<div class="optionfield"><code>Dim</code> or <code>Dim1</code>, <code>Dim2</code>,... </div>
<div class="optiondescr">
For a one-dimensional experiment <code>Dim</code> or <code>Dim1</code> provide the fields to change and by how much.
Simulations with more than one dimension (field <code>nPoints</code>) require <code>Dim1</code>, <code>Dim2</code>,... . 
The first data point always uses the initially defined values.
For pulses, all fields that appear in the definition can be changed.
<pre class="matlab">
Exp.Dim1 = {p2.Flip pi/8};        % increments the flip angle of the second pulse by pi/8 each step
</pre>
With free evolution events only the length can be changed:
<pre class="matlab">
Exp.Dim1 = {d3 -0.1};             % decremeants the length of the third delay by 100 ns each step
</pre>
Several parameters can be changed in one dimension:
<pre class="matlab">
Exp.Dim1 = {p2.Flip pi/8; d3 -0.1}; % flip angle of second pulse, length of the third free evolution event
Exp.Dim1 = {p2.Flip,p3.Flip pi/8};  % flip angles of the second and third pulse are simulaneously stepped  
</pre>
For experiments that involve one or several moving pulses, the identifier <code>Position</code> can be used.
This can only be used for pulses that are not the first or last event in the sequence. 
Pulses are allowed to cross over each other, but must not overlap, else an error is returned.
<pre class="matlab">
Exp.Dim2 = {p2.Position 0.1};   % moves the pulse 100 ns back each step in the 2nd dimension
</pre>
Non-linear increments can be used by providing vectors with the desired increments.
Important, the first value is still taken as the one in the sequence definition, and hence the length of the vector with the increments must be one element shorter than the requested number of data points:
<pre class="matlab">
Exp.nPoints = 5;
Exp.Dim = {d2 [0.1 0.3 0.65 -0.2]};   % non-linear increment of the second delay
</pre>
A special case is the field <code>Frequency</code> in the pulse definition of a frequency swept pulse.
Here it is necessary to provide a vector for a linear increment, with the first element being the change to the initial frequency and the second being the change of the final frequency:
<pre class="matlab">
Exp.Dim1 = {p1.Frequency [-0.005 0.005]};   % increases sweep width by 10 MHz each step
Exp.Dim1 = {p1.Frequency [0.005 0.005]};    % moves the excitation band by 10 MHz each step
</pre>
</div>

<p>
Bandwidth limitations of the resonator on a pulse can be incorporated into simulations:
</p>
<div class="optionfield"><code>Resonator</code></div>
<div class="optiondescr">
The resonator profile has to be defined using the resonator center frequency <code>nu0</code> and the loaded Q-value <code>QL</code> or the transfer function <code>TransferFunction</code> in combination with the frequency axis <code>nu</code>
By setting <code>Mode</code> it is possible to compensate for the resonator which provides a signal that corresponds to the desired signal in the resonator.
For more details see <a class="esf" href="resonator.html">resonator</a>.
<div class="optionfield"><code>nu0</code></div>
<div class="optiondescr">
Resonator center frequency in GHz.
</div>
<div class="optionfield"><code>QL</code></div>
<div class="optiondescr">
The loaded Q-value.
</div>
<div class="optionfield"><code>nu</code></div>
<div class="optiondescr">
Frequency axis of the resonator transfer function in GHz.
</div>
<div class="optionfield"><code>TransferFunction</code></div>
<div class="optiondescr">
If the transfer function input is real, it is interpreted as magnitude transfer function.
If it is complex it is taken as the full transfer function.
</div>
<div class="optionfield"><code>Mode</code></div>
<div class="optiondescr">
Optional, can be <code>'simulate'</code> or <code>'compensate'</code>. 
By default the effect of the resonator on the signal is simulated.
If set to <code>'compensate'</code> the effect of the resonator is compensated.
</div>
</div>

<div class="subtitle2">Input: Simulation options</div>
<p>
<code>Opt</code> contains additional simulation parameters.
</p>

<div class="optionfield"><code>FrameShift</code></div>
<div class="optiondescr">
For many simulations it is possible to use a rotating frame at a frequency <code>FrameShift</code> in GHz instead of the labframe.
This reduces the required timestep and strongly reduces processing time.
</div>

<div class="optionfield"><code>DetOperator</code></div>
<div class="optiondescr">
The field <code>DetOperator</code> is a cell array that contains detection operators. 
They can be defined by using the same syntax as for the function <a class="esf" href="sop.html">sop</a>: 
<pre class="matlab">
Opt.DetOperator = {'+1' 'z1'};   % detects S+ and Sz of the first electron spin
</pre>
Detection operators that can not be defined using the <code>sop</code> syntax, can be provided in matrix form:
<pre class="matlab">
Opt.DetOperator = {[0 1; 0 0] [1/2 0; 0 -1/2]};   % the same operators as a above for S = 1/2 in matrix form
</pre>
If no detection operator is provided, yet detection is still requested with <code>DetEvents</code>, S<sub>+</sub> is used.
</div>

<div class="optionfield"><code>FreqTranslation</code></div>
<div class="optiondescr">
As detection is done in the simulation frame, all signals from detection operators, that have non-zero off-diagonal elements, have a rotating component.
This high-frequency oscillation can be removed by down conversion with a frequency in GHz.
The indexing in <code>FreqTranslation</code> corresponds to the ordering in <code>DetOperator</code>:
<pre class="matlab">
Opt.DetOperator = {'+1' 'z1'};   	% detects S+ and Sz of the first electron spin
Opt.FreqTranslation = [-33.5 0]; 	% shifts S+ by -33.5 GHz, Sz does not contain a rotating component
</pre>
If counterrotating components S<sub>-</sub> are detected, they sign for the frequency shift needs to change:
<pre class="matlab">
Opt.DetOperator = {'+1' '-1'};		% detects S+ and S- of the first electron spin
Opt.FreqTranslation = [-33.5 33.5]; 	% shifts S+ by -33.5 GHz and S- by 33.5 GHz
</pre>
If down conversion fails, the signals in the lab frame are returned.
</div>

<div class="optionfield"><code>Relaxation</code></div>
<div class="optiondescr">
Relaxation can be switched on for the entire sequence as well as event specific:
<pre class="matlab">
Opt.Relaxation = true;   	% switches on relaxation for the entire simulation
Opt.Relaxation = [0 0 1];	% relaxation is active only during the third event
</pre>
If relaxation is switched on relaxation times need to be provided and the simulation is then performed in Liouville space, which slows down the simulation significantly.
</div>

<div class="optionfield"><code>StateTrajectories</code></div>
<div class="optiondescr">
If <code>StateTrajectories</code> is active, the output contains a cell array with the cell arrays for each timestep.
<code>StateTrajectories</code> can be switched on for the entire sequence as well as specific events:
<pre class="matlab">
Opt.StateTrajectories = true;   	% switches on state trajectories for the entire simulation
Opt.StateTrajectories = [0 0 1];	% state trajectories is active only during the third event
</pre>
State trajectories can only be recorded properly for events where detecion is active.
</div>

<div class="optionfield"><code>ComplexExcitation</code></div>
<div class="optiondescr">
If <code>ComplexExcitation</code> is active, the excitation operator also uses the imaginary part of the waveform.
The default excitation then becomes S<sub>x</sub><code>real</code>(<code>IQ</code>)+S<sub>y</sub><code>imag</code>(<code>IQ</code>).
It can be switched on for all pulses or specific pulses. In the latter the indexing corresponds to the pulse index, not the event index.
<pre class="matlab">
Opt.ComplexExcitation = true;     % switches on complex excitation for all pulses
Opt.ComplexExcitation = [0 1 0];  % complex excitation is active only during the second pulse (not event)
</pre>
</div>

<div class="optionfield"><code>ExcOperator</code></div>
<div class="optiondescr">
By default S<sub>x</sub> is used as excitation operator. 
With the cell array <code>ExcOperator</code> it is possible to custom excitation operators.
The indexing of <code>ExcOperator</code> corresponds to the pulse index.
It is possible to use the syntax from <a class="esf" href="sop.html">sop</a> as well as matrices: 
<pre class="matlab">
Opt.ExcOperator = {[] 'x(1|2)'};     % transition selective excitation operator for the second pulse
Opt.ExcOperator = {[0 1/2; 1/2 0]};  % custom excitation operator for the first pulse in matrix form
</pre>
The imaginary part of a custom excitation operator is only considered if <code>ComplexExcitation</code> is active for the respective pulse.
</div>



</div>




<div class="subtitle">Tips and Tricks</div>
<ul>
<li>
If you are interested in S<sub>x</sub>, it is usually beneficial to use S<sub>+</sub> as the actual detection operator and then take the real part of the obtained signal.
This removes artifacts at the beginning and end of the time traces that arise from down conversion. 
<li> 
Talk about multidimensional experiments and the ordering of it (dimensions etc)
</ul>


<div class="subtitle">See also</div>
<p>
<a class="esf" href="saffron.html">saffron</a>,
<a class="esf" href="pepper.html">pepper</a>,
<a class="esf" href="resonator.html">resonator</a>

<hr>

</section>

<footer></footer>

</body>
</html>
